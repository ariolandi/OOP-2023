# Потоци и файлове

## Синтаксис

### Работа с файлове

**ifstream:** входен поток за четене от файл, наследяващ istream
**ofstream:** изходен поток за писане във файл, наследяващ ostream
**fstream:** входно-изходен поток за писане и четене във файл

При отваряне на даден файл се дефинира обект от тип ifstream/ofstream/fstream, който получава като аргумент име на файл, който да бъде отворен. След приключване на работа с него, файлът трябва да бъде затворен (с метод close()). Един и същи обект може да се преизползва за различни файлове - след затваряне на предишния, нов файл се отваря чрез метода open(filename).

**Забележка:** ако за даден клас са предефинирани операторите за вход и изход, то те могат да получат като лявостоящ аргумент поток за работа с файлове и това ще сработи. 

#### Пример:
```c++
class A {
    int x;
public:
    friend istream& operator>>(istream&, A&);
    friend ostream& operator<<(ostream&, const A&);
};

istream& operator>>(istream& is, A& object) {
    is >> object.x;

    return is;
}

ostream& operator<<(ostream& os, const A& object) {
    os << object.x;

    return os;
}

A a;
ifstream fin(input_filename);
oftream fout(output_filename);
if (!fin || !fout) throw std::runtime_error("Invalid file");   // проверка за правилно отворени файлове
fin >> a;
fout << a << std::endl;
fin.close();
fout.close();
```

Освен име на файл, както конструктора, така и open могат да приемат режим на работа. Това е специална поредица от битове, която указва къде да се поставят указателите за писане и четене. При използване на няколко режима, те се изреждат с побитово "или". Ако не е заданен режим на работа, се използва този по подразбиране за съответния вид файл.

**Режими за достъп:**
* ios::in - отваря файл за извличане и поставя за четене указателя в началото; по подразбиране за входни файлове
* ios::out - отваря файл за писане и поставя указателя за писане в началото; по подразбиране за изходни файлове
* ios::app - отваря файл за писане и поставя указателя за писане в края на файла; указателят не може да бъде преместен
* ios::ate - отваря файл за писане и поставя указателя за писане в края на файла; указателят може да бъде преместен
* ios::trunc - ако файлът съществува, съдържанието се изтрива; по подразбиране при активен ios::out
* ios::binary - отваря файл в двоичен режим на работа


**Работа с указатели за писане и четене:**
* seekg - премества указателя за четене с N байта спрямо позиция във файла
* seekp - премества указателя за писане с N байта спрямо позиция във файла
* tellg - връща текущата позиция на указателя за четене
* tellp - връща текущата позиция на указателя за хисане


**Позиции във файл:**
* ios::beg - указател към началото на файла
* ios::end - указател към края на файла
* ios::curr - указател към текущата позиция във файла

**Текстови файл:** файл с последователен достъп, представен като редица от символи. Чете се ред по ред.
**Двоичен файл:** файл с пряк достъп. Елементите му са с фиксирана дължина и могат да бъдат достъпени директно с адреса си.

Силно препоръчително е при работа с двоични файлове всички обекти да имат една и съща дължина, т.е. да не се използва динамична памет, за да се четат директно байтове вместо текст, както и да се достъпва директно даден елемент, подобно на масив. 
Динамичната памет все пак може да се запише във файл, отворен като двоичен, но тогава е необходимо файлът да се третира като такъв с последователен достъп.

**Оператори за писане и четене в двоичен файл:**
* read(*str_stream*, *stream_size*) - прочита в *str_stream* (низ) *stream_size* на брой байтове от файла
* write(*str_stream*, *stream_size*) - записва във файла *stream_size* на брой байтове от *str_stream* (низ)

#### Пример:
```c++
class A {
    int x;
public:
};


A a;
oftream fout(output_filename, std::ios::binary);
if (!fout) throw std::runtime_error("Invalid file"); 
fout.write((char*)&a, sizeof(a));   // записва обекта a във файла под формата на байтове
fout.close();
```

## Задачи

#### Задача 1
База данни ще наричаме двоичен файл с формат *.db, съдържащ записани първо определен брой потребители с тяхното име, парола и роля, а след това информация за набор от продукти с баркод, вид, цена и количество. Преди всеки низ е записано цяло число - неговата дължина. Склад използва система за управление на база данни, даваща следните възможноти:
* Влизане в системата на потребител с потребителско име и парола
    - ако името и/или паролата са грешни, да се хвърля грешка
    - името и паролата не съдържат интервали
    - в една система може да има само един активен потребител в даден момент
    - всеки потребител може да със статус на системен администратор или да бъде обикновен потребител
    - статусът на даден потребител може да бъде повишен от обикновен до администратор от друг администратор
    - статусът на даден потребител *не може* да бъде понижен
* Изход на потребител от системата
* Добавяне или премахване на потребител
    - това действие може да бъде изпълнено само от администратор
    - всички потребителски имена в системата трябва да са уникални
    - потребител не може да изтрие собствения си акаунт
* Проверка за наличност от даден продукт
* Промяна (добавяне или премахване) на наличните бройки от даден продукт
* Промяна на цената за даден продукт
    - това действие може да бъде извършвано само от администратор
* Добавяне или изтриване на продукти
    - това действие може да бъде извършвано само от администратор
    - баркодовете на всички продукти в системата са уникални

Реализирайте програма за управление на описаната система. Нека всяка система има на свързания файл, както и първоначален потребител с администраторски права. Също система да може да се създаде чрез вече съществуващ файл.
Всички низове във файла ще бъдат с дължина до 50 символа.
