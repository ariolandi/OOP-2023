# Потоци и файлове

## Синтаксис

### Работа с потоци

**Поток:** поредица от байтове, абстрактен канал за данни с последователен достъп. Използват се за пренос на данни.
Входящият поток се нарича istrean (input stream), а изходящият - ostream (output stream).

Познатите оператори за вход (>>) и изход (<<) приемат като свой лявостоящ аргумент и имат тип на връщане референция към съответно входен и изходен поток. Най-често това са cin (console input - стандартен вход) и cout (console output - стандартен изход). Дясностоящия аргумент е съответния обект/променлива, чиито данни обработваме.


За даден клас могат да се предефинират оператори за вход и изход като приятелски функции.

#### Пример:
```c++
class A {
    int x;
public:
    friend istream& operator>>(istream&, A&);
    friend ostream& operator<<(ostream&, const A&);
};

istream& operator>>(istream& is, A& object) {
    is >> object.x;

    return is;
}

ostream& operator<<(ostream& os, const A& object) {
    os << object.x;

    return os;
}

A a;
std::cin >> a;
std::cout << a << std::endl;
```

**Други полезни потоци:**
* std::cerr - поток за изход на грешки, отделен от стандартния изход. Небуфериран - съобщенията се извеждат веднага.
* std::clog - поток за логване на данни, отделен от стандартния изход. Буфериран - съобщенията се натрупват и се извеждат наведнъж.

**Методи за потоци:**
* get - извлича един или повече елементи ог входен поток
* put - добавя елемент в изходен поток
* write - записва информацията от буфер в изходен поток

**Състояние на поток:**
* good
* end of file
* bad
* fail


### Работа с файлове

**ifstream:** входен поток за четене от файл, наследяващ istream
**ofstream:** изходен поток за писане във файл, наследяващ ostream
**fstream:** входно-изходен поток за писане и четене във файл

При отваряне на даден файл се дефинира обект от тип ifstream/ofstream/fstream, който получава като аргумент име на файл, който да бъде отворен. След приключване на работа с него, файлът трябва да бъде затворен (с метод close()). Един и същи обект може да се преизползва за различни файлове - след затваряне на предишния, нов файл се отваря чрез метода open(filename).

**Забележка:** ако за даден клас са предефинирани операторите за вход и изход, то те могат да получат като лявостоящ аргумент поток за работа с файлове и това ще сработи. 

#### Пример:
```c++
class A {
    int x;
public:
    friend istream& operator>>(istream&, A&);
    friend ostream& operator<<(ostream&, const A&);
};

istream& operator>>(istream& is, A& object) {
    is >> object.x;

    return is;
}

ostream& operator<<(ostream& os, const A& object) {
    os << object.x;

    return os;
}

A a;
ifstream fin(input_filename);
oftream fout(output_filename);
if (!fin || !fout) throw std::runtime_error("Invalid file");   // проверка за правилно отворени файлове
fin >> a;
fout << a << std::endl;
fin.close();
fout.close();
```

Освен име на файл, както конструктора, така и open могат да приемат режим на работа. Това е специална поредица от битове, която указва къде да се поставят указателите за писане и четене. При използване на няколко режима, те се изреждат с побитово "или". Ако не е заданен режим на работа, се използва този по подразбиране за съответния вид файл.

**Режими за достъп:**
* ios::in - отваря файл за извличане и поставя за четене указателя в началото; по подразбиране за входни файлове
* ios::out - отваря файл за писане и поставя указателя за писане в началото; по подразбиране за изходни файлове
* ios::app - отваря файл за писане и поставя указателя за писане в края на файла; указателят не може да бъде преместен
* ios::ate - отваря файл за писане и поставя указателя за писане в края на файла; указателят може да бъде преместен
* ios::trunc - ако файлът съществува, съдържанието се изтрива
* ios::binary - отваря файл в двоичен режим на работа


**Работа с указатели за писане и четене:**
* seekg - премества указателя за четене с N байта спрямо позиция във файла
* seekp - премества указателя за писане с N байта спрямо позиция във файла
* tellg - връща текущата позиция на указателя за четене
* tellp - връща текущата позиция на указателя за хисане


**Позиции във файл:**
* ios::beg - указател към началото на файла
* ios::end - указател към края на файла
* ios::curr - указател към текущата позиция във файла

**Текстови файл:** файл с последователен достъп, представен като редица от символи. Чете се ред по ред.
**Двоичен файл:** файл с пряк достъп. Елементите му са с фиксирана дължина и могат да бъдат достъпени директно с адреса си.

 

## Задачи

#### Задача 1
Аня и Ванката използват споделен гугъл календар и често бъркат събитията си. Затова един ден Ванката е решил да напише собствена система за менажиране на събития и ви е извикал да му помогнете. В системата има различни потребители, като информацията за тях се пази на твърдия диск под формата на текстови файл (той може да има различни имена за различните инстанции на системата). В календара може както да се влиза с вече запаметени потребителско име и парола, така и да се създава нов потребител. 
От своя страна, всеки потребител може да регистрира събития в собствения си календар. Едно събитие се състои от описание, дата във формат dd/mm/yyyy и час във формат hh:mm. Нека цялата информация за събитията да може да се извежда на екрана.

#
#### Задача 2
Реализирайте система, подобна на СУСИ. Нека да има възможност за:
1. въвеждане на нов студент с две имена и факултетен номер
2. добавяне на предмети, записани от даден студент
3. извеждане на информация за даден студент на стандартния изход

Информацията за всеки студент се пази във файл със съответното име. 
**Пример:**
*gosho_petrov.txt*
```
Gosho Petrov 81123
Algebra
DataBases
DataStructures
OOP
```

Нека при въвеждане на нов предмет се прави валидация за съществуваща дисциплина. Всички валидни дисциплини са записани във файл *subjects.txt* (или друго име по ваш избор). Имената на файловете, съдържащи информация за студентите, са записани във файл  *students.txt* (или друго име по ваш избор). Нека при изход от системата цялата информация да се записва на твърдия диск. 

**Ограничения:** 
* Името и фамилията на студента не са по-дълги от 100 символа и без интервали.
* Наименованието на даден предмет е не по-дълго от 50 символа и без интервали. 
* Във файловете students.txt и subjects.txt няма по повече от 100 записа.


