# Класове - канонично представяне

## Канонично представяне - "голяма четворка"
* Конструктор
* Копиращ конструктор
* Оператор за присвояване
* Деструктор


## Синтаксис

### Динамична памет в клас

Когато се налага да използваме динамична памет в полетата на даден клас, нейното заделяне се случва в конструктора на класа. Съответно изтриването й - в деструктор. 

Деструктор наричаме специален метод без тип на връщане и параметри, чието име съвпада с името на класа, предшествано от тилда (**~**). Неговата роля е да изтрие заделената динамична памет. Извикването му става автоматично при унищожаване на обекта в края на областта, в която е дефиниран. 


#### Пример:
```c++
class Person {
    char *name;
    int age;

public:
    Person(const char* name, const int age) {       // конструктор
        this->name = new char[strlen(name) + 1];    // заделяне на динамичната памет
        strcpy(this->name, name);
        this->age = age;
    }

    ~Person() {                                     // деструктор
        delete[] this->name;                        // изтриване на заделената динамична памет
        // полето age съдържа статична памет и няма нужда да правим нищо спрямо него
    }
};

{                                                   // област, в която дефинираме обекта p
    Person p("vankata", 20);
}                                                   // край на областта, извиква се деструктор за p
```

Копиращият конструктор е специален вид конструктор, използван при създаване на копие на обект. Той е само един за всеки клас и ако липсва дефиниция, се създава автоматично. Когато в класа присъства динамична памет, дефиницията му е задължителна.

#### Пример:
```c++
class Person {
    char *name;
    int age;

public:
    Person(const char* name, const int age) {            // конструктор
        this->name = new char[strlen(name) + 1];         // заделяне на динамичната памет
        strcpy(this->name, name);
        this->age = age;
    }

    Person(const Person& other) {                        // Копиращ конструктор
        this->name = new char[strlen(othe.name) + 1];    // заделяне на динамичната памет
        strcpy(this->name, other.name);
        this->age = other.age;
    }

    ~Person() {
        delete[] this->name;                       
    }
};

                                               
Person p("vankata", 20);
Person p1(p);                                       // Извикване на копиращ конструктор
```

Възможно е в клас да се предефинират някои оператори. Когато в класа присъства динамична памет, предефинирането на оператор за присвояване е задължително. Неговата задача е при подаден **различен от текущия** обект да се изтрие вече заделената динамична памет и да се копират данните на подадения обект в текущия. По конвенция, в края на изпълнението се връща **референция към текущия обект**. 

Предефинирането на оператор се случва с ключова дума **operator**, следван от съответния запазен символ без интервал между тях. Като параметри се подава дясностоящия аргумент, а лявостоящ става текущия обект. 

#### Пример:
```c++
class Person {
    char *name;
    int age;

    void create(const char* name, const int age) {       // помощна функция за създаване на обект
        this->name = new char[strlen(name) + 1];         // заделяне на динамичната памет
        strcpy(this->name, name);
        this->age = age;
    }

    void copy(const Person& other) {                     // помощна функция за копиране на обект
        create(other.name, other.age); 
    }

    void delete() {                                      // помощна функция за изтриване на динамичната памет
        delete[] this->name;
    }

public:
    Person(const char* name, const int age) {            // конструктор
        create(name, age);
    }

    Person(const Person& other) {                        // Копиращ конструктор
        copy(other);
    }

    Person& operator=(const Person& other) {             // оператор за присвояване с тип на връщате референция към текущия обект
        if (this != &other) {                            // сравняване по адрес на обектите, за да не се окажат един и същ
            delete();                                    // изтриване на вече заделената памет 
            copy(other);                                 // копиране на данните от подадения обект
        }

        return *this;                                    // връщане на (деференциран) текущия обект
    }

    ~Person() {                                          // деструктор
        delete();            
    }
};

                                               
Person p("vankata", 20);
Person p1(p);                                       // Извикване на копиращ конструктор
Person p2("anya", 18);
p2 = p1;                                            // Извикване на оператор за присвояване
```


| Сценарий                | Извиква се              | 
| ----------------------- | ------------------------|
| Person b(a);            | копиращ констрктор      | 
| Person b = a;           | копиращ конструктор     |
| Person b("", 0); b = a; | оператор за присвояване |
| void f(Person p)        | копиращ констрктор      |
|void f(Person& p)        | нито едното             |

## Задачи

#### Задача 1
Реализирайте клас String за улеснение на работата с динамични низове.

#
#### Задача 2
Колегите от Физическия факултет отново са се забъркали в страшна каша - този път ще строят космическа станция! След добро количество време, прекарано в изчисления, са стигнали до не много сложния извод, че начинанието им ще се нуждае и от подходящ софтуер. 
Един модул съдържа определено предварително изчислено количество совалки, които могат да го използват за престой. Всяка космическа станция разполага с определен първоначален брой модули за кацане. Но понеже постоянно се включват нови модули, а от време на време космически кораби излитат обратно и някои модули биват разкачени, когато се изпразнят, този брой се променя непрекъснато. Съответно трябва за всяка совалка, поискала разрешение за кацане, или да се намери първото свободно място на площадката, или тя да се разшири. Също така от време на време ще пристигне цяла флотилия от кораби, които трябва да бъдат настанени. 
От своя страна, всяка совалка съдържа информация за кодовото си наименование (символен низ), колко души екипаж са на борда и максимален капацитет на горивото.
Напишете софтуер, който управлява една космическа станция - дава възможност за включване или изключване на модул към площадката за кацане, за кацане на една или повече совалки едновременно и за излитането на совалка (по кодово наименование).
