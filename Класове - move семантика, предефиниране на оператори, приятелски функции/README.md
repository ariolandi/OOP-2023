# Класове - move семантика, предефиниране на оператори, приятелски функции

## Синтаксис

### Move семантика

* Когато подаваме стойност по референция, то на практика подаваме адрес в паметта.
* "Временни обекти" - обекти, които е невъзможно да бъдат достъпени повече от веднъж. Обикновено се създават само и единствено при присвояване на стойности. Такива обекти означаваме с `<тип>&&`.

#### Пример:
```c++
class Person {
    char *name;
    int age;

public:
    Person(const char* name, const int age);
    Person(const Person& other);
    Person& operator=(const Person& other);
    ~Person();
};
                                               
Person p("Vankata", 20);            
Person p_copy(p);                               // p е реален обект
Person p_nameless(Person("Anya", 17));          // Person("Anya", 17) не е реален обект и няма начин да бъде достъпен отново                                          
```

Move семантиката се използва основно при копиращи конструктори и оператори за присвояване. Целта е при подаден временен обект да се прехвърли **собствеността на паметта** от временния към текущия обект. По този начин не се прави излишно заделяне, копиране и изтриване на памет.

#### Пример:
```c++
class Person {
    char *name;
    int age;

    void copy(Person&& other) {
        // прехвърляне на собствеността на паметта
        this->name = other.name;
        this->age = other.age;

        // зануляване на подадения обект
        other.name = nullptr;                   // не извикваме delete - прехвърлили сме указателя от текущия обект да сочи към паметта от подадения и не искаме да я трием, а да пренасочим указателя на подадения обект към друга стойност
        other.age = 0;
    }

public:
    Person(const char* name, const int age);
    Person(const Person& other);
    Person& operator=(const Person& other);
    ~Person();

    Person(Person&& other) {                    // да се обърне внимание, че обектът не е константен
        copy(other);
    }

    Person& operator=(Person&& other) {         // да се обърне внимание, че обектът не е константен
        if (this != other) {                    // поради механизмите за преобразуване от реален към временен обект, тази проверка все още е необходима
            delete[] this->name;
            copy(other);
        }

        return *this;
    }
};
                                               
Person p("Vankata", 20);            
Person p_copy(p);                               // p е реален обект, ще се извика move конструктор
Person p_nameless(Person("Anya", 17));          // Pesson("Anya", 17) не е реален обект, извиква се move конструктор 

Person p_cast((Person&&)p);                     // p е реален обект, но го преобразуваме до временен, извиква се move конструктор
```

**Забележка:** при липса на дефинирани move конструктор и/или оператор за присвояване се извикват съответно копиращ конструктор и стандартен оператор за присвояване. 

Обектите могат да бъдат премествани и с **std::move**.
#### Пример:
```c++
void swap(Person& a, Person& b) {
    Person temp(std::move(a));   // данните от a се преместват в обекта temp
    a = std::move(b);            // повтаряме процедурата от b към a
    b = std::move(temp);         // и от temp към b
}
```


### Приятелски функции и класове

Приятелска функция наричаме външна функция, която има достъп до private полетата и методи на даден клас. Това се обозначава със запазената дума `friend`, последвана от типа на връщане, името и типа параметри на съответната функция.
```
class A {
public:
    friend <тип> <име>(<аргументи>);
};
```

Аналогично, приятелски клас е такъв външен клас, който има достъп до private полетата и методи на даден клас. Това се обозначава със запазената дума `friend`, последвана от запазена дума `class` и името на класа.
```
class A {
public:
    friend class <име>;
};
```

#### Пример:
```c++
class Point {
    double x, y;

public:
    Point(const double x, const double y): x(x), y(y) {}

    friend double distance(const Point&, const Point&);
};

double distance(const Point& a, const Point& b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));     // тук няма проблем да достъпим Point::x и Point::y, въпреки че са вътрешни за класа
}
```

| Спецификатор | Видимост в класа | Видимост от външния свят | Видимост от приятелски функции/класове |
| ------------ | ---------------- | ------------------------ | -------------------------------------- |
| private      | да               | не                       | да                                     |
| protected    | да               | не                       | да                                     |
| public       | да               | да                       | да                                     |


**Забележка:** В общия случай, приятелските функции противоречат на енкапсулацията, затова трябва да се използват внимателно. Вътрешните методи са за предпочитане навсякъде, където това е възможно. 


### Оператори. Предефиниране на оператори

Видове оператори:
- бинарни (с два аргумента)
    - инфиксни
- унарни (с един аргумент)
    - префиксни
    - постфиксни

Предефинирането на оператор се случва с ключова дума **operator**, следван от съответния запазен символ без интервал между тях. Той може да е както приятелска функция, така и вътрешен метод за клас. 

Ако е дефиниран като вътрешен метод за клас, то тогава първи (лявостоящ) операнд става текущия обект и се подава само втория (дясностоящ) операнд като аргумент на метода, ако има нужда от това.

#### Пример:
Следните две дефиниции са еквивалентни:

```c++
class Point {
    double x, y;

public:
    Point(const double x, const double y): x(x), y(y) {}

    friend Point operator+(const Point&, const Point&);
};

Point operator+(const Point& a, const Point& b) {
    return Point(a.x + b.x, a.y + b.y);
}
```

```c++
class Point {
    double x, y;

public:
    Point(const double x, const double y): x(x), y(y) {}

    Point operator+(const Point& other) const {
        return Point(this->x + other.x, this->y + other.y);
    }
};
```


**Специални случаи:**
- Има някои непредифируеми оператори: **\*** в ролята си на префиксен оператор, **.**, **->**, **?:** (тернарен оператор), **::** и други.
- Добрата практика изисква оператор [] да присъства както за константни обекти (в ролята на getter), така и за неконстантни (връщайки референция към съответния обект).
```c++
class A {
public:
    const A& operator[](const int index) const; // ако обектът е константен, ще се извика този оператор, позволявайки да се види стойността на дадена позиция
    A& operator[](const int index);             // ако обектът не е константен, ще се извика този оператор, позволявайки да се види или промени стойността на дадена позиция
};
```
- Операторите **++** и **--** имат както постфиксна, така и префиксна версия. За да се различат един от друг, постфиксният оператор приема тип int като анонимен аргумент.
```c++
class A {
    int x;
public:
    A operator++() {            // префиксен оператор
        this->x += 1;
        return *this;
    }

    A operator++(int) {         // постфиксен оператор
        int tmp = this->x; 
        this->x += 1;
        return this->x;
    }
};
```

## Задачи

**За всички задачи се изисква реализацията на move семантика.**

#### Задача 1
Да се реализира клас Студент, притежаващ име и факултетен номер (цяло число). Да се реализира клас Курс, притежаващ име, описание и списък със студенти. Нека класът курс има предефиниран оператор [], който по подаден факултетен номер връща референция към съответния студент. 

#
#### Задача 2
Аня скоро се е заела с ботаника. Според нея е достатъчно дадено дърво да се характеризира с неговия сорт (бук, ясен, върба...) и възраст. Съответно, тя е решила да си отглежда гора! И понеже е програмист, тя иска това да се случва динамично, т.е. да може да добавя или премахва дървета в края на гората по всяко време. 
Аня се нуждае от вашата помощ за реализирането на следната функционалност:
- нека всяко дърво да има оператор ++, увеличаващ неговата възраст с една година
- нека дърветата да могат да се сравняват:
    - две дървета са различни, ако са от различни сортове
    - едно дърво е по-малко от друго, ако е от същия сорт, но е на по-малко години
    - две дървета са равни, ако са от един и същи сорт и на едни и същи години
- нека гората представлява редица дървета и има опеатор += за добавяне на дърво в края на редицата (съответно -= за премахване)

Да се реализира външна функция unique, която приема гора и връща нейно копие, от което са премахнати всички повтарящи се дървета. 
