# Шаблони и наследяване

## Синтаксис

### Работа с шаблони

**Шаблон** на функция или клас се нарича такъв блок код, описващ функционалност, която не зависи от тип. Шаблон се дефинира чрез **template <typename** *име_на_типа* **>** преди декларацията на клас или функция. По конвенция, шаблонния тип се означава като **T**. Една функция или клас може да съдържа един или повече шаблонни типа.


#### Пример:
```c++
template <typename T>
T sum(const T& a, const T& b) {
    return a + b;                   // това ще работи за всеки тип T, който има предефиниран оператор +
}

struct Point{
    double x, y;
    Point(const double x, const double y): x(x), y(y) {}

    Point operator+(const Point& other) {
        return Point(x + other.x, y + other.y);
    } 
};

int a = 5, b = 3;
sum(a, b);                          // <=>  sum<int>(a, b)
Point p1(3.4, 1), p2(78.2, 86.3);
sum(p1, p2);                        // <=>  sum<Point>(p1, p2)
```

#### Пример:
```c++
template <typename T, template U>
struct Pair {
    T first;
    U second;
};

Pair<char, double> p{'a', 3.4};     // T == char, U == double
```

При дефиниране на шаблонен клас, това все още не е реален клас, а само абстракция. Едва при опит за създаване на обект, тогава се декларира клас, където шаблонът е заместен с определен тип и за всеки обект се заделя съответното количество памет.


#### Пример:
```c++
template <typename T>
class Array {
    T* arr;
    int size;
public:
    Array(const int);
    ...
    T& operator[](const int);
};

// конструкцията template <typename T> се повтаря преди дефиницията на всеки метод
// самият клас и неговата област се достъпва чрез името на класа, последвато от типа, вписан в остри скоби
template <typename T>
Array<T>::Array(const int size): size(size) {
    arr = new T[size];      // този ред ще доведе до грешка, ако се опитаме да инизиализираме T с тип, който няма конструктор по подразбиране
}

...
template <typename T>
T& Array<T>::operator[](const int index) {
    return arr[index];
}


Array<char> c(4);           // създаваме обект от клас, в който типът T отговаря на тип char. Създава се съответния клас
c[2] = 'd';
```


**Употреба:**
* Дефиниция на "обобщени" класове
* Преизползване на код
* Създаване на споделена функционалност
* Създаване на контейнери и структури от данни


### Наследяване

**Наследяващият (производен) клас** получава всички полета и методи от **наследения (базов) клас**, като излючение са тези, дефинирани в private секцията - до тях липсва пряк достъп от производния клас. Тук е и основната разлика между спецификаторите за достъп **private** и **protected**.

| Спецификатор | Видимост в класа | Видимост от външния свят | Видимост в производен клас |
| ------------ | ---------------- | ------------------------ | -------------------- ----- |
| private      | да               | не                       | не                         |
| protected    | да               | не                       | да                         | 
| public       | да               | да                       | да                         |


Наследяващият клас от своя страна също може да скрива дадени полета от наследения клас, правейки ги недостъпни за останалия свят. Това се случва чрез **спецификатор за достъп** при самото наследяване. Ако такъв не е посочен, то по подразбиране се смята за **private**. Правилото е, че член-данните от всяка секция от базовия клас попадат или в същата секция в производния, или в такава с по-строг достъп, в зависимост от спецификатора при наследяването.

| Спецификатор при наследяване | Секция от базовия клас | Секция от производния клас |
| ---------------------------- | ---------------------- | -------------------------- |
| private                      | private                | private (без пряк достъп)  |
| private                      | protected              | private                    |
| private                      | public                 | private                    |
| protected                    | private                | private (без пряк достъп)  |
| protected                    | protected              | protected                  |
| protected                    | public                 | protected                  |
| public                       | private                | private (без пряк достъп)  |
| public                       | protected              | protected                  |
| public                       | public                 | public                     |


Правилото, че всеки клас се грижи за собствените си полета, важи и тук. Производният клас извиква методите от базовия клас, когато това е възможно, вместо да променя стойностите на неговите член-данни. Също така е възможно някои функции да бъдат предефинирани в производния клас.

#### Пример:
```c++
class Person {
protected:
    std::string name;
    int age;
public:
    Person(const std::string name, const int age): name(name), age(age);
};

class Student: protected Person {
    int fn;
/*
имплицитно се случва това:
protected:
    Person::name;
    Person::age
    Person::Person
*/
public:
    // конструкторът приема всички необходими данни за Person и извиква неговия конструктор
    Student(const std::string name, const int age, const int fn): Person(name, age), fn(fn) {}
};
```

#### Пример:
```c++
class Person {
protected:
    std::string name;
    int age;
public:
    Person(const std::string name, const int age): name(name), age(age);
    void print() const {
        std::cout << name << " " << age;
    }
};

class Student: protected Person {
    int fn;
public:
    Student(const std::string name, const int age, const int fn): Person(name, age), fn(fn) {}
    void print() const {
        Person::print();        // извиква се метода от базовия клас 
        std::cout << " " << fn;
    }
};

Person p("Vankata", 25);
Student a("Anya", 25, 1234);
p.print();                      // извиква се Person::print
a.print();                      // извиква се Student::print
```
 


## Задачи

#### Задача 1
Ванката наскоро реши да усъвършенства календара, който с Аня реализираха преди няколко седмици - сега той изпраща списък от напомняния на телефона му. Всяко напомняне в идеалния случай се състои от име на събитието, час във формат hh:mm и дата във формат dd-mm-yyyy. Нещо обаче се е объркало в кода и Ванката получава три вида напомняния, нито един от които не е в пълен формат:
- напомняне, съдържащо име на събитието и неговия час
- напомняне, съдържащо име на събитието и неговата дата
- напомняне, съдържащо само дата и час
С цел поне малко да ги огранизира, Ванката ви моли да му помогнете в написването на клас, който разделя напомнянията по тип и ги сортира по дата и час. 
*Използвайте помощен клас Pair, както и методи за сравняване на обекти от тип Pair. За низовете използвайте std::string или реализацията на String от упражнения, където е необходимо. Разрешено е използването на std::vector. Реализирайте външна функция sort, която приема вектор или масив от произволен тип и го сортира по избран от вас метод.*

#
#### Задача 2
Аня много обича пролетта, но не е особен фен на променливото време. Съответно един дъждовен следобед, тя решава да състави метод на систематизация на времето. Тя реализира клас Weather, който описва атмосферните условия в един ден - колко градуса по целзий е температурата навън и сила на вятъра. Съответно, обаче, същестувва и възможността за RainyWeather - когато са възможни валежи и Аня иска да си запише процентната вероятност за тях, SunnyDay - слънчев ден, но Аня няма друга информация за него (просто си отбелязва, че е слънчев), и RandomWeatherDay - времето има две различни състояния и Аня иска да ги запише и двете в един и същи обект.
*Реализирайте подходяща йерархия от класове, която повтаря тази на Аня. Използвайте наследяване и композиция на класове, където е необходимо.*
